#pragma once

#include <memory>
#include <string>
#include <utility>
#include "binder/binder_context.h"
#include "catalog/catalog_defs.h"
#include "common/sql_node_visitor.h"
#include "parser/postgresparser.h"
#include "parser/statements.h"

namespace terrier {

namespace parser {
class SQLStatement;
class CaseExpression;
class ConstantValueExpression;
class ColumnValueExpression;
class SubqueryExpression;
class StarExpression;
class OperatorExpression;
class AggregateExpression;
}  // namespace parser

namespace catalog {
class CatalogAccessor;
}  // namespace catalog

namespace binder {

/**
 * Interface to be notified of the composition of a bind node.
 */
class BindNodeVisitor : public SqlNodeVisitor {
 public:
  /**
   * Initialize the bind node visitor object with a pointer to a catalog accessor, and a default database name
   * @param catalog_accessor Pointer to a catalog accessor
   * @param default_database_name Default database name
   */
  BindNodeVisitor(std::unique_ptr<catalog::CatalogAccessor> catalog_accessor, std::string default_database_name);
  ~BindNodeVisitor() override { delete context_; }

  /**
   * Perform binding on the passed in tree. Bind the ids according to the names in the tree.
   * For example, bind the corresponding database oid to an expression, which has a database name
   * @param tree Parsed in AST tree of the SQL statement
   */
  void BindNameToNode(common::ManagedPointer<parser::SQLStatement> tree, parser::ParseResult *parse_result);

  /**
   * This method is used by the QueryToOperatorTransformer to take ownership of the catalog accessor.
   * @return catalog accessor
   */
  std::unique_ptr<catalog::CatalogAccessor> GetCatalogAccessor() { return std::move(catalog_accessor_); }

  /**
   * Traverse and bind components of the select statement with the actual data storage in the database
   * @param node Select statement to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::SelectStatement *node, parser::ParseResult *parse_result) override;

  // Some sub query nodes inside SelectStatement
  /**
   * Traverse and bind components of the join definition with the actual data storage in the database
   * @param node Join definition to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::JoinDefinition *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the table reference ofbject with the actual data storage in the database
   * @param node TableRef object to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::TableRef *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the group-by description with the actual data storage in the database
   * @param node GroupBy description to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::GroupByDescription *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the order-by defination with the actual data storage in the database
   * @param node OrderBy description to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::OrderByDescription *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the limit description with the actual data storage in the database
   * @param node Select statement to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::LimitDescription *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the create statement with the actual data storage in the database
   * @param node Create statement to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::CreateStatement *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the create function statement with the actual data storage in the database
   * @param node CreateFunction statement to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::CreateFunctionStatement *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the insert statement with the actual data storage in the database
   * @param node Insert statement to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::InsertStatement *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the delete statement with the actual data storage in the database
   * @param node Delete statement to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::DeleteStatement *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the drop statement with the actual data storage in the database
   * @param node Drop statement to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::DropStatement *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the prepare statement with the actual data storage in the database
   * @param node Prepare statement to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::PrepareStatement *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the execute statement with the actual data storage in the database
   * @param node Execute statement to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::ExecuteStatement *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the transaction statement with the actual data storage in the database
   * @param node Transaction statement to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::TransactionStatement *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the update statement with the actual data storage in the database
   * @param node Update statement to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::UpdateStatement *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the copy statement with the actual data storage in the database
   * @param node Copy statement to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::CopyStatement *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the analyze statement with the actual data storage in the database
   * @param node Analyze statement to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::AnalyzeStatement *node, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the case expression with the actual data storage in the database
   * @param node Case expression to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::CaseExpression *expr, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the subquery expression with the actual data storage in the database
   * @param node Subquery expression to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::SubqueryExpression *expr, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the constant value expression with the actual data storage in the database
   * @param node Constant value expression to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::ConstantValueExpression *expr, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the column value expression with the actual data storage in the database
   * @param node Column value expression to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::ColumnValueExpression *expr, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the star expression with the actual data storage in the database
   * @param node Star expression to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::StarExpression *expr, parser::ParseResult *parse_result) override;

  //  TODO(Ling): implement this after we add support for function expression
  //  void Visit(parser::FunctionExpression *expr, parser::ParseResult *parse_result) override;

  // Deduce value type for these expressions
  /**
   * Traverse and bind components of the operator expression with the actual data storage in the database
   * @param node Operator expression to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::OperatorExpression *expr, parser::ParseResult *parse_result) override;

  /**
   * Traverse and bind components of the aggregate expression with the actual data storage in the database
   * @param node Aggregate expression to be traversed
   * @param parse_result The ast generated by the parser
   */
  void Visit(parser::AggregateExpression *expr, parser::ParseResult *parse_result) override;

 private:
  /** Current context of the query or subquery **/
  BinderContext *context_ = nullptr;
  /** Catalog accessor **/
  std::unique_ptr<catalog::CatalogAccessor> catalog_accessor_;
  /** Default database name of the query. Default to current database reside in **/
  std::string default_database_name_;
};

}  // namespace binder
}  // namespace terrier
